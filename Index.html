<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DartMerge</title>
    <!-- Google Fonts: Inter for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for basic utilities and responsive classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Base styles for the body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background for a modern feel */
            color: #e2e8f0; /* Light text for contrast */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content is too tall */
        }

        /* Game container styling */
        #game-container {
            background-color: #2d3748; /* Slightly lighter dark background for the container */
            border-radius: 15px; /* Rounded corners for the container */
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3); /* Soft shadow for depth */
            width: 100%;
            max-width: 600px; /* Max width for better desktop experience */
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between sections */
            border: 2px solid #4a5568; /* Subtle border */
        }

        /* Title styling */
        h1 {
            text-align: center;
            font-size: 3.5rem; /* Increased heading size */
            font-weight: 700;
            color: #63b3ed; /* A vibrant blue for the title */
            text-shadow: 0 0 10px rgba(99, 179, 237, 0.5); /* Glowing text effect */
            margin-bottom: 20px;
        }

        /* Styling for all number blocks (top, drop zone, grid) */
        .number-block, .grid-cell-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px; /* Consistent size for blocks */
            height: 60px;
            border-radius: 10px; /* Rounded corners for blocks */
            font-weight: 700;
            font-size: 1.2rem;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; /* Smooth transitions for hover/active states */
            user-select: none; /* Prevent text selection */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); /* Soft shadow */
            border: 2px solid rgba(255, 255, 255, 0.1); /* Subtle white border */
            color: #e2e8f0; /* Text color for numbers */
        }

        /* Cursor for clickable elements */
        .clickable {
            cursor: pointer;
        }
        .clickable:hover:not(.disabled) {
            transform: translateY(-3px); /* Lift effect on hover */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .clickable:active:not(.disabled) {
            transform: translateY(0); /* Press effect on click */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .number-block.disabled {
            opacity: 0.5; /* Dim disabled blocks */
            cursor: not-allowed;
        }

        /* Specific block colors based on value */
        .block-2 { background-color: #63b3ed; } /* Light Blue */
        .block-4 { background-color: #48bb78; } /* Green */
        .block-8 { background-color: #ecc94b; } /* Yellow */
        .block-16 { background-color: #ed8936; } /* Orange */
        .block-32 { background-color: #f56565; } /* Red */
        .block-64 { background-color: #9f7aea; } /* Purple */
        .block-128 { background-color: #ed64a6; } /* Pink */
        .block-256 { background-color: #4fd1c5; } /* Teal */
        .block-512 { background-color: #a0522d; } /* Sienna Brown */
        .block-1024 { background-color: #2b6cb0; } /* Dark Blue */
        /* No 2048 block color needed as it's removed from options */
        .block-miss { background-color: #a0aec0; } /* Gray for 'Miss' */
        .block-bomb { background-color: #e53e3e; } /* Red for 'Bomb' */
        .block-block-swap { background-color: #805ad5; } /* Violet for 'Block Swap' */
        .block-hammer { background-color: #718096; } /* Dark Gray for 'Hammer' */
        .block-empty { background-color: #4a5568; } /* Background for empty grid cells */

        /* Top section for dartboard and button */
        #top-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background-color: #2d3748;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #dartboard-canvas {
            background-color: #1a202c;
            border-radius: 50%; /* Make it round */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 250px; /* Max size for dartboard */
            max-height: 250px;
            width: 100%; /* Responsive width */
            height: auto; /* Maintain aspect ratio */
            border: 5px solid #4a5568;
        }

        #throw-dart-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
            color: #e2e8f0;
            background-image: linear-gradient(to right, #4299e1, #63b3ed); /* Blue gradient */
        }
        #throw-dart-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-image: linear-gradient(to right, #3182ce, #4299e1);
        }
        #throw-dart-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #throw-dart-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-image: linear-gradient(to right, #a0aec0, #cbd5e0);
        }


        /* Drop zone container */
        #drop-zone-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background-color: #2d3748;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #drop-zone {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 70px; /* Ensure space even when empty */
            align-items: center;
            width: 100%;
        }
        #drop-zone .number-block {
            width: 60px; /* Standard size for drop zone blocks */
            height: 60px;
            font-size: 1.2rem;
            border: 2px dashed #90cdf4; /* Dashed border for visual distinction */
        }
        #drop-zone .number-block.selected-for-drop {
            border: 2px solid #fc8181; /* Red border when selected for dropping */
            box-shadow: 0 0 15px rgba(252, 129, 129, 0.7); /* Red glow when selected */
        }

        /* Action buttons (Undo, Reset Game) */
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
        }
        .action-buttons button {
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
            color: #e2e8f0;
            background-image: linear-gradient(to right, #4299e1, #63b3ed); /* Blue gradient */
        }
        .action-buttons button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-image: linear-gradient(to right, #3182ce, #4299e1);
        }
        .action-buttons button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .action-buttons button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-image: linear-gradient(to right, #a0aec0, #cbd5e0);
        }

        /* Game grid styling */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 columns, equal width */
            grid-template-rows: repeat(5, 1fr); /* 5 rows, equal height */
            gap: 5px; /* Space between grid cells */
            width: 100%;
            aspect-ratio: 1 / 1; /* Make the grid perfectly square */
            background-color: #1a202c;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); /* Inner shadow for depth */
            border: 2px solid #4a5568;
        }
        .grid-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4a5568; /* Background for empty cells */
            border-radius: 8px;
            position: relative;
            overflow: hidden; /* Important for glowing effect to stay within bounds */
            transition: background-color 0.2s ease-in-out;
        }
        /* Only apply active/hover styles if drop zone is full */
        .drop-zone-full .grid-cell.column-active {
            box-shadow: 0 0 0 3px #90cdf4, inset 0 0 0 3px #90cdf4; /* Highlight active column for dropping */
            cursor: pointer;
        }
        .drop-zone-full .grid-cell.column-active:hover {
            background-color: #5a667a; /* Slightly lighter on hover when active */
        }
        /* New style for selected swap blocks */
        .drop-zone-full .grid-cell.selected-for-swap {
            box-shadow: 0 0 0 4px #805ad5, inset 0 0 0 4px #805ad5; /* Violet glow for selected swap block */
            background-color: #6b46c1; /* Slightly darker violet */
        }
        .drop-zone-full .grid-cell.selected-for-swap:hover {
            background-color: #744edc; /* Lighter violet on hover */
        }
        /* New style for selected hammer target */
        .drop-zone-full .grid-cell.selected-for-hammer {
            box-shadow: 0 0 0 4px #e53e3e, inset 0 0 0 4px #e53e3e; /* Red glow for hammer target */
            background-color: #c53030; /* Slightly darker red */
        }
        .drop-zone-full .grid-cell.selected-for-hammer:hover {
            background-color: #d64545; /* Lighter red on hover */
        }


        /* Keyframe animation for the glowing effect */
        @keyframes glow {
            0% { box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #63b3ed, 0 0 20px #63b3ed, 0 0 25px #63b3ed, 0 0 30px #63b3ed, 0 0 35px #63b3ed; }
            100% { box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #63b3ed, 0 0 40px #63b3ed, 0 0 50px #63b3ed, 0 0 60px #63b3ed, 0 0 70px #63b3ed; }
        }
        /* Apply glowing animation to the highest value block */
        .grid-cell-content.glowing {
            animation: glow 1.5s infinite alternate; /* Continuous, alternating glow */
        }

        /* New style for merge animation */
        @keyframes mergePulse {
            0% { transform: scale(1); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(99, 179, 237, 0.8), 0 0 40px rgba(99, 179, 237, 0.6); }
            100% { transform: scale(1); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); }
        }
        .grid-cell-content.merge-pulse {
            animation: mergePulse 0.3s ease-out;
        }

        /* Game info section (Score, Highest Value) */
        #game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2rem;
            font-weight: 700;
            color: #90cdf4; /* Blue text for info */
        }

        /* Game Over Modal */
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            visibility: hidden; /* Hidden by default */
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease-in-out; /* Smooth fade in/out */
        }
        #game-over-modal.show {
            visibility: visible;
            opacity: 1;
        }
        #game-over-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
            max-width: 90%; /* Responsive width */
        }
        #game-over-content h2 {
            font-size: 2.5rem;
            color: #fc8181; /* Red for "Game Over" */
            margin-bottom: 20px;
        }
        #game-over-content p {
            font-size: 1.5rem;
            margin-bottom: 25px;
        }
        #game-over-content button {
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-image: linear-gradient(to right, #48bb78, #68d391); /* Green gradient for restart */
            color: #e2e8f0;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        #game-over-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-image: linear-gradient(to right, #38a169, #48bb78); /* Darker green on hover */
        }

        /* Info Message Box (replaces alert()) */
        #info-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4299e1; /* Blue background */
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1001; /* Above modal */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .number-block, .grid-cell-content {
                width: 50px;
                height: 50px;
                font-size: 1rem;
            }
            #dartboard-canvas {
                max-width: 200px;
                max-height: 200px;
            }
            #drop-zone .number-block {
                width: 55px;
                height: 55px;
                font-size: 1.1rem;
            }
            .action-buttons button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            #game-info {
                font-size: 1rem;
            }
            #game-over-content h2 {
                font-size: 2rem;
            }
            #game-over-content p {
                font-size: 1.2rem;
            }
            #game-over-content button {
                padding: 12px 25px;
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Audio tag for background music -->
    <audio id="background-music" src="Dartsmerge Theme Song.mp3" loop autoplay></audio>

    <div id="game-container">
        <h1>DartMerge</h1>

        <!-- Section for the dartboard and throw button -->
        <div id="top-section">
            <canvas id="dartboard-canvas" class="clickable"></canvas>
            <button id="throw-dart-button">Throw Dart</button>
        </div>

        <!-- Section for the drop zone and undo button -->
        <div id="drop-zone-container">
            <div id="drop-zone">
                <!-- Numbers dropped from the top will appear here -->
            </div>
            <div class="action-buttons">
                <button id="undo-button">Undo (3)</button>
                <button id="reset-game-button">Reset Game</button>
            </div>
        </div>

        <!-- The 5x5 game grid -->
        <div id="game-grid">
            <!-- Grid cells and their contents will be dynamically rendered here by JavaScript -->
        </div>

        <!-- Game information: Score and Highest Value -->
        <div id="game-info">
            <span>Score: <span id="score">0</span></span>
            <span>Highest: <span id="highest-value">0</span></span>
            <span>High Score: <span id="high-score">0</span></span>
        </div>
    </div>

    <!-- Game Over Modal (hidden by default) -->
    <div id="game-over-modal">
        <div id="game-over-content">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Highest Block: <span id="modal-highest-value">0</span></p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // Dartboard specific constants
        const DARTBOARD_SEGMENTS_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

        // User-defined mapping for single segments
        const DARTBOARD_SINGLE_SEGMENT_MAPPING = {
            20: 32, 1: 32,
            13: 64, 6: 64,
            10: 128, 15: 128,
            2: 2, 17: 2,
            3: 256, 19: 256,
            18: 4, 4: 4,
            8: 8, 11: 8,
            7: 16, 16: 16,
            14: 512, 9: 512,
            12: 1024, 5: 1024
        };

        // Probabilities for hitting different areas of the dartboard (sum to 1)
        const DART_HIT_PROBABILITIES = {
            'single': 0.60, // High chance for regular numbers
            'double': 0.15, // Medium chance for Hammer
            'triple': 0.15, // Medium chance for Bomb
            'bull': 0.05,   // Low chance for Block Swap (Bullseye)
            'outer_bull': 0.03, // Very low chance for Block Swap (Outer Bull)
            'miss': 0.02    // Very low chance for Miss
        };

        const MAX_DROP_ZONE_SIZE = 3; // Maximum numbers allowed in the drop zone
        const MAX_UNDO_COUNT = 3;     // Maximum times the undo button can be used
        const GRID_SIZE = 5;          // The grid dimensions (5x5)
        const HIGH_SCORE_KEY = 'dartMergeHighScore'; // Key for localStorage

        // Mapping values to their corresponding CSS color classes
        const blockColors = {
            2: 'block-2',
            4: 'block-4',
            8: 'block-8',
            16: 'block-16',
            32: 'block-32',
            64: 'block-64',
            128: 'block-128',
            256: 'block-256',
            512: 'block-512',
            1024: 'block-1024',
            'Miss': 'block-miss',
            'Bomb': 'block-bomb',
            'Block Swap': 'block-block-swap',
            'Hammer': 'block-hammer',
            0: 'block-empty' // Class for empty grid cells
        };

        // All game logic and variables are now encapsulated within the window.onload function
        window.onload = function () {
            // Game state variables, initialized to their default values
            let gameGrid = []; // Represents the 5x5 game board, 0 indicates an empty cell
            let dropZoneNumbers = []; // Array to hold numbers currently in the drop zone
            let undoCount = MAX_UNDO_COUNT; // Tracks remaining undo uses
            let score = 0; // Current game score
            let highestValue = 0; // Highest number currently in the grid
            let highScore = 0; // Persistent high score
            let selectedDropZoneIndex = -1; // Index of the number selected in drop zone for placement (-1 means none)
            let isDroppingMode = false; // Flag to indicate if a number is selected for dropping into the grid
            let firstSwapBlock = null; // Stores [row, col] of the first block selected for Block Swap
            let undoHistory = []; // Stores previous game states for the undo functionality

            // Get references to key DOM elements - assigned here to ensure they are available
            const dartboardCanvas = document.getElementById('dartboard-canvas');
            const ctx = dartboardCanvas.getContext('2d');
            const throwDartButton = document.getElementById('throw-dart-button');
            const dropZoneDiv = document.getElementById('drop-zone');
            const undoButton = document.getElementById('undo-button');
            const resetGameButton = document.getElementById('reset-game-button');
            const gameGridDiv = document.getElementById('game-grid');
            const scoreSpan = document.getElementById('score');
            const highestValueSpan = document.getElementById('highest-value');
            const highScoreSpan = document.getElementById('high-score');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreSpan = document.getElementById('final-score');
            const modalHighestValueSpan = document.getElementById('modal-highest-value');
            const restartButton = document.getElementById('restart-button');
            const backgroundMusic = document.getElementById('background-music');
            const topSectionDiv = document.getElementById('top-section');

            // Tone.js setup for sound effects
            let dropSynth, mergeSynth, missSynth, bombSynth, hammerSynth, swapSynth;

            /**
             * Initializes Tone.js synths for various sound effects.
             * This function should be called after a user interaction to ensure audio context starts.
             */
            function setupAudio() {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                dropSynth = new Tone.MembraneSynth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }
                }).toDestination();

                mergeSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.1 }
                }).toDestination();

                missSynth = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }
                }).toDestination();

                bombSynth = new Tone.MetalSynth({
                    envelope: { decay: 0.3, sustain: 0.1 },
                    resonance: 0.9
                }).toDestination();

                hammerSynth = new Tone.PluckSynth({
                    attackNoise: 1,
                    dampening: 4000,
                    resonance: 0.9
                }).toDestination();

                swapSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.02, decay: 0.1, sustain: 0.0, release: 0.2 }
                }).toDestination();
            }

            function playDropSound() { dropSynth.triggerAttackRelease("C3", "8n"); }
            function playMergeSound() { mergeSynth.triggerAttackRelease("E5", "16n"); }
            function playMissSound() { missSynth.triggerAttackRelease("8n"); }
            function playBombSound() { bombSynth.triggerAttackRelease("C2", "1n"); }
            function playHammerSound() { hammerSynth.triggerAttackRelease("A2", "8n"); }
            function playSwapSound() { swapSynth.triggerAttackRelease(["C5", "G5"], "8n"); }


            /**
             * Returns the CSS class name for a given number value or special block.
             * @param {number|string} value - The block value (e.g., 2, 'Miss', 'Bomb', 'Block Swap', 'Hammer').
             * @returns {string} The corresponding CSS class name.
             */
            function getBlockColorClass(value) {
                return blockColors[value] || 'block-empty';
            }

            /**
             * Loads the high score from localStorage.
             */
            function loadHighScore() {
                const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
                highScore = storedHighScore ? parseInt(storedHighScore, 10) : 0;
            }

            /**
             * Saves the current high score to localStorage if it's higher than the stored one.
             */
            function saveHighScore() {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem(HIGH_SCORE_KEY, highScore.toString());
                }
            }

            /**
             * Draws the dartboard on the canvas.
             */
            function drawDartboard() {
                const size = dartboardCanvas.width;
                const center = size / 2;
                const radius = size / 2 - 5; // Leave some padding for border

                ctx.clearRect(0, 0, size, size); // Clear canvas

                // Draw segments and rings
                const segmentAngle = (Math.PI * 2) / 20; // Angle for each of 20 segments

                // Define ring radii (relative to total radius)
                const bullseyeRadius = radius * 0.05;
                const outerBullRadius = radius * 0.12;
                const tripleInnerRadius = radius * 0.5;
                const tripleOuterRadius = radius * 0.6;
                const doubleInnerRadius = radius * 0.9;
                const doubleOuterRadius = radius * 1.0;

                for (let i = 0; i < 20; i++) {
                    const startAngle = i * segmentAngle - Math.PI / 20 - Math.PI / 2; // Adjust for 20 at top, and start angle
                    const endAngle = (i + 1) * segmentAngle - Math.PI / 20 - Math.PI / 2;

                    // Outer Single (between double and triple)
                    ctx.beginPath();
                    ctx.arc(center, center, doubleInnerRadius, startAngle, endAngle);
                    ctx.arc(center, center, tripleOuterRadius, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = (i % 2 === 0) ? '#333' : '#eee'; // Alternating dark/light gray
                    ctx.fill();

                    // Inner Single (between triple and bullseye)
                    ctx.beginPath();
                    ctx.arc(center, center, tripleInnerRadius, startAngle, endAngle);
                    ctx.arc(center, center, outerBullRadius, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = (i % 2 === 0) ? '#eee' : '#333'; // Alternating light/dark gray
                    ctx.fill();
                }

                // Draw Triple Ring
                ctx.beginPath();
                ctx.arc(center, center, tripleOuterRadius, 0, Math.PI * 2);
                ctx.arc(center, center, tripleInnerRadius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fillStyle = '#f56565'; // Red
                ctx.fill();

                // Draw Double Ring
                ctx.beginPath();
                ctx.arc(center, center, doubleOuterRadius, 0, Math.PI * 2);
                ctx.arc(center, center, doubleInnerRadius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fillStyle = '#48bb78'; // Green
                ctx.fill();

                // Draw Outer Bull (25)
                ctx.beginPath();
                ctx.arc(center, center, outerBullRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#48bb78'; // Green
                ctx.fill();

                // Draw Bullseye (50)
                ctx.beginPath();
                ctx.arc(center, center, bullseyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#f56565'; // Red
                ctx.fill();

                // Draw lines for segments
                ctx.strokeStyle = '#2d3748'; // Darker line color
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    const angle = i * segmentAngle - Math.PI / 20 - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(center, center);
                    ctx.lineTo(center + radius * Math.cos(angle), center + radius * Math.sin(angle));
                    ctx.stroke();
                }

                // Draw outer border
                ctx.beginPath();
                ctx.arc(center, center, radius, 0, Math.PI * 2);
                ctx.strokeStyle = '#e2e8f0'; // Light border
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            /**
             * Updates all dynamic parts of the UI (dartboard, drop zone, grid, score, highest value, undo button state, high score).
             */
            function updateUI() {
                drawDartboard();
                renderDropZone();
                renderGrid();
                scoreSpan.textContent = score;
                highestValueSpan.textContent = highestValue;
                highScoreSpan.textContent = highScore; // Update high score display
                undoButton.textContent = `Undo (${undoCount})`;
                undoButton.disabled = undoCount === 0 || undoHistory.length === 0;

                // Add/remove class to game-grid based on drop zone fullness for styling purposes
                if (dropZoneNumbers.length === MAX_DROP_ZONE_SIZE) {
                    gameGridDiv.classList.add('drop-zone-full');
                } else {
                    gameGridDiv.classList.remove('drop-zone-full');
                }
            }

            /**
             * Renders the numbers currently in the drop zone.
             */
            function renderDropZone() {
                dropZoneDiv.innerHTML = ''; // Clear existing blocks
                dropZoneNumbers.forEach((value, index) => {
                    const block = document.createElement('div');
                    block.classList.add('number-block', getBlockColorClass(value));
                    if (index === selectedDropZoneIndex) {
                        block.classList.add('selected-for-drop');
                    }
                    block.textContent = value;
                    block.dataset.value = value;
                    block.dataset.index = index;
                    block.addEventListener('click', () => handleDropZoneClick(index));
                    dropZoneDiv.appendChild(block);
                });
            }

            /**
             * Renders the 5x5 game grid, including numbers and empty cells.
             * Highlights columns if in dropping mode, or individual cells if in Block Swap/Hammer mode.
             */
            function renderGrid() {
                gameGridDiv.innerHTML = ''; // Clear existing grid cells
                const selectedDropZoneValue = dropZoneNumbers[selectedDropZoneIndex];
                const isDropZoneFull = dropZoneNumbers.length === MAX_DROP_ZONE_SIZE;

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        // Only enable grid interaction if drop zone is full AND a block is selected
                        if (isDroppingMode && isDropZoneFull) {
                            if (selectedDropZoneValue === "Block Swap") {
                                cell.classList.add('column-active'); // Reusing for general clickable state
                                if (firstSwapBlock && firstSwapBlock[0] === r && firstSwapBlock[1] === c) {
                                    cell.classList.add('selected-for-swap'); // Highlight the first selected block
                                }
                                cell.addEventListener('click', () => handleGridCellClickForSwap(r, c));
                            } else if (selectedDropZoneValue === "Hammer") {
                                cell.classList.add('column-active'); // Highlight all cells for hammer target
                                cell.classList.add('selected-for-hammer'); // Specific glow for hammer
                                cell.addEventListener('click', () => handleGridCellClickForHammer(r, c));
                            }
                            else {
                                // For regular numbers or Bomb, only columns are clickable
                                cell.classList.add('column-active');
                                cell.addEventListener('click', () => handleGridColumnClick(c));
                            }
                        }

                        const value = gameGrid[r][c];
                        if (value !== 0) { // If the cell is not empty
                            const content = document.createElement('div');
                            content.classList.add('grid-cell-content', 'number-block', getBlockColorClass(value));
                            content.textContent = value;
                            if (value === highestValue && highestValue !== 0) {
                                content.classList.add('glowing');
                            }
                            cell.appendChild(content);
                        }
                        gameGridDiv.appendChild(cell);
                    }
                }
            }


            /**
             * Calculates the total score by summing all numbers in the grid.
             */
            function calculateScore() {
                let currentScore = 0;
                gameGrid.forEach(row => {
                    row.forEach(value => {
                        if (typeof value === 'number') { // Only sum actual numbers
                            currentScore += value;
                        }
                    });
                });
                score = currentScore;
            }

            /**
             * Finds the highest value number currently present in the grid.
             */
            function getHighestValue() {
                let maxVal = 0;
                gameGrid.forEach(row => {
                    row.forEach(value => {
                        if (typeof value === 'number' && value > maxVal) {
                            maxVal = value;
                        }
                    });
                });
                highestValue = maxVal;
            }

            /**
             * Simulates a dart throw based on predefined probabilities and dartboard logic.
             * @returns {number|string} The game value (number or special block).
             */
            function simulateDartThrow() {
                const rand = Math.random();
                let cumulativeProbability = 0;
                let hitZone = '';

                // Determine hit zone based on probabilities
                for (const zone in DART_HIT_PROBABILITIES) {
                    cumulativeProbability += DART_HIT_PROBABILITIES[zone];
                    if (rand <= cumulativeProbability) {
                        hitZone = zone;
                        break;
                    }
                }

                switch (hitZone) {
                    case 'miss':
                        return "Miss";
                    case 'bull':
                    case 'outer_bull':
                        return "Block Swap";
                    case 'double':
                        return "Hammer";
                    case 'triple':
                        return "Bomb";
                    case 'single':
                        // Pick a random segment from the dartboard order
                        const randomSegmentIndex = Math.floor(Math.random() * DARTBOARD_SEGMENTS_ORDER.length);
                        const dartboardSegment = DARTBOARD_SEGMENTS_ORDER[randomSegmentIndex];
                        return DARTBOARD_SINGLE_SEGMENT_MAPPING[dartboardSegment];
                    default:
                        // Fallback, should not happen if probabilities sum to 1
                        return 2; // Default to a small number
                }
            }

            /**
             * Handles the click event on the "Throw Dart" button.
             * Generates a new block based on dartboard logic and adds it to the drop zone.
             */
            function handleThrowDartClick() {
                if (dropZoneNumbers.length < MAX_DROP_ZONE_SIZE) {
                    // Save the current game state before adding to drop zone
                    undoHistory.push({
                        grid: JSON.parse(JSON.stringify(gameGrid)),
                        dropZone: [...dropZoneNumbers],
                        undoCount: undoCount,
                        score: score,
                        highestValue: highestValue,
                        firstSwapBlock: firstSwapBlock
                    });

                    const newBlockValue = simulateDartThrow();
                    dropZoneNumbers.push(newBlockValue);
                    updateUI();
                } else {
                    showInfoMessage("Drop zone is full! Place a number in the grid first.");
                }
            }

            /**
             * Handles the click event on the undo button.
             * Reverts the game state to the previous one if undos are available.
             */
            function handleUndoClick() {
                if (undoCount > 0 && undoHistory.length > 0) {
                    const prevState = undoHistory.pop(); // Get the last saved state
                    // Restore game state from history
                    gameGrid = prevState.grid;
                    dropZoneNumbers = prevState.dropZone;
                    undoCount = prevState.undoCount - 1; // Decrement undo count
                    score = prevState.score;
                    highestValue = prevState.highestValue;
                    firstSwapBlock = prevState.firstSwapBlock; // Restore firstSwapBlock
                    selectedDropZoneIndex = -1; // Clear any active selection
                    isDroppingMode = false; // Exit dropping mode
                    updateUI(); // Refresh the UI
                }
            }

            /**
             * Handles the click event on a number in the drop zone.
             * Toggles the selection of a number for placement into the grid or for a special action.
             * @param {number} index - The index of the clicked number in the dropZoneNumbers array.
             */
            function handleDropZoneClick(index) {
                if (selectedDropZoneIndex === index) {
                    // If the same number is clicked again, deselect it
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    firstSwapBlock = null; // Clear firstSwapBlock on deselect
                } else {
                    // Check if drop zone is full before allowing selection for grid placement/special action
                    if (dropZoneNumbers.length < MAX_DROP_ZONE_SIZE) {
                        showInfoMessage("Drop zone must be full before placing blocks in the grid!");
                        return; // Prevent selection if drop zone is not full
                    }

                    // Select the number and enter dropping mode
                    selectedDropZoneIndex = index;
                    isDroppingMode = true;
                    firstSwapBlock = null; // Clear firstSwapBlock on new selection
                    const selectedValue = dropZoneNumbers[selectedDropZoneIndex];
                    if (selectedValue === "Block Swap") {
                        showInfoMessage("Select the first block to swap.");
                    } else if (selectedValue === "Hammer") {
                        showInfoMessage("Select a block in the grid to remove.");
                    }
                }
                updateUI(); // Refresh UI to show selection/deselection
            }

            /**
             * Handles the click event on a grid column when in dropping mode (for numbers/bomb).
             * Places the selected number into the lowest available space in that column.
             * @param {number} col - The column index where the number should be placed.
             */
            function handleGridColumnClick(col) {
                // Ensure drop zone is full before allowing placement
                if (dropZoneNumbers.length < MAX_DROP_ZONE_SIZE) {
                    showInfoMessage("Drop zone must be full before placing blocks!");
                    // Deselect the block and exit dropping mode since placement is not allowed
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    updateUI();
                    return;
                }

                if (!isDroppingMode || selectedDropZoneIndex === -1) return;

                const valueToPlace = dropZoneNumbers[selectedDropZoneIndex];
                if (valueToPlace === undefined) return;

                // Save state BEFORE any action that modifies the grid or drop zone
                undoHistory.push({
                    grid: JSON.parse(JSON.stringify(gameGrid)),
                    dropZone: [...dropZoneNumbers],
                    undoCount: undoCount,
                    score: score,
                    highestValue: highestValue,
                    firstSwapBlock: firstSwapBlock
                });

                // --- LOGIC FOR 'MISS' BLOCK ---
                if (valueToPlace === "Miss") {
                    playMissSound(); // Play miss sound
                    dropZoneNumbers.splice(selectedDropZoneIndex, 1);
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    showInfoMessage("Miss block disappeared!");
                    updateUI();
                    return;
                }
                // --- END LOGIC FOR 'MISS' BLOCK ---

                // --- LOGIC FOR 'BOMB' BLOCK ---
                if (valueToPlace === "Bomb") {
                    playBombSound(); // Play bomb sound
                    for (let r = 0; r < GRID_SIZE; r++) {
                        gameGrid[r][col] = 0; // Clear each cell in the column
                    }
                    dropZoneNumbers.splice(selectedDropZoneIndex, 1); // Remove bomb from drop zone
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    showInfoMessage(`Column ${col + 1} cleared by Bomb!`);
                    processGridChanges(); // Recalculate score and highest value
                    updateUI();
                    checkGameOver();
                    return;
                }
                // --- END LOGIC FOR 'BOMB' BLOCK ---

                let targetRow = -1;
                // Find the lowest available (empty) space in the selected column
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (gameGrid[r][col] === 0) {
                        targetRow = r;
                        break;
                    }
                }

                if (targetRow !== -1) {
                    gameGrid[targetRow][col] = valueToPlace;
                    dropZoneNumbers.splice(selectedDropZoneIndex, 1);

                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;

                    playDropSound(); // Play drop sound
                    processGridChanges();
                    updateUI();
                    checkGameOver();
                } else {
                    // Game over condition: Column is full
                    showGameOverModal();
                }
            }

            /**
             * Handles clicks on grid cells specifically when "Block Swap" is active.
             * @param {number} r - The row index of the clicked cell.
             * @param {number} c - The column index of the clicked cell.
             */
            function handleGridCellClickForSwap(r, c) {
                // Ensure drop zone is full before allowing action
                if (dropZoneNumbers.length < MAX_DROP_ZONE_SIZE) {
                    showInfoMessage("Drop zone must be full before using special blocks!");
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    firstSwapBlock = null;
                    updateUI();
                    return;
                }

                if (!isDroppingMode || dropZoneNumbers[selectedDropZoneIndex] !== "Block Swap") return;

                if (!firstSwapBlock) {
                    // First block selected for swap
                    firstSwapBlock = [r, c];
                    showInfoMessage("Select the second block to swap.");
                } else {
                    // Second block selected for swap
                    const secondSwapBlock = [r, c];

                    // Prevent swapping a block with itself
                    if (firstSwapBlock[0] === secondSwapBlock[0] && firstSwapBlock[1] === secondSwapBlock[1]) {
                        showInfoMessage("Cannot swap a block with itself. Select a different block.");
                        firstSwapBlock = null; // Reset first selection
                        updateUI();
                        return;
                    }

                    // Save state BEFORE the swap action
                    undoHistory.push({
                        grid: JSON.parse(JSON.stringify(gameGrid)),
                        dropZone: [...dropZoneNumbers],
                        undoCount: undoCount,
                        score: score,
                        highestValue: highestValue,
                        firstSwapBlock: firstSwapBlock // Save the state of firstSwapBlock too
                    });

                    // Perform the swap
                    const temp = gameGrid[firstSwapBlock[0]][firstSwapBlock[1]];
                    gameGrid[firstSwapBlock[0]][firstSwapBlock[1]] = gameGrid[secondSwapBlock[0]][secondSwapBlock[1]];
                    gameGrid[secondSwapBlock[0]][secondSwapBlock[1]] = temp;

                    // Remove "Block Swap" from drop zone after use
                    dropZoneNumbers.splice(selectedDropZoneIndex, 1);

                    // Reset swap state
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    firstSwapBlock = null;

                    playSwapSound(); // Play swap sound
                    showInfoMessage("Blocks swapped!");
                    processGridChanges(); // Check for new merges and falling blocks after swap
                    updateUI();
                    checkGameOver();
                }
                updateUI(); // Always update UI after a click in swap mode
            }

            /**
             * Handles clicks on grid cells specifically when "Hammer" is active.
             * Removes the selected block from the grid.
             * @param {number} r - The row index of the clicked cell.
             * @param {number} c - The column index of the clicked cell.
             */
            function handleGridCellClickForHammer(r, c) {
                // Ensure drop zone is full before allowing action
                if (dropZoneNumbers.length < MAX_DROP_ZONE_SIZE) {
                    showInfoMessage("Drop zone must be full before using special blocks!");
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    updateUI();
                    return;
                }

                if (!isDroppingMode || dropZoneNumbers[selectedDropZoneIndex] !== "Hammer") return;

                // Save state BEFORE the hammer action
                undoHistory.push({
                    grid: JSON.parse(JSON.stringify(gameGrid)),
                    dropZone: [...dropZoneNumbers],
                    undoCount: undoCount,
                    score: score,
                    highestValue: highestValue,
                    firstSwapBlock: firstSwapBlock // Ensure this is saved even if not used by hammer
                });

                // Remove the block
                gameGrid[r][c] = 0;

                // Remove "Hammer" from drop zone after use
                dropZoneNumbers.splice(selectedDropZoneIndex, 1);

                // Reset hammer state
                selectedDropZoneIndex = -1;
                isDroppingMode = false;

                playHammerSound(); // Play hammer sound
                showInfoMessage("Block removed by Hammer!");
                processGridChanges(); // Check for falling blocks after removal
                updateUI();
                checkGameOver();
            }


            /**
             * Orchestrates the merging and dropping of blocks after a number is placed or swapped.
             * This function repeatedly checks for merges until no more merges can occur,
             * then makes all blocks fall.
             */
            function processGridChanges() {
                let mergesOccurred;
                do {
                    mergesOccurred = false; // Assume no merges occurred in this pass
                    // Iterate through the entire grid to find and perform merges
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            const currentValue = gameGrid[r][c];
                            // Skip empty cells or special blocks for merging
                            if (currentValue === 0 || typeof currentValue !== 'number') continue; // Only numbers merge

                            // Define directions to check for adjacent blocks (Up, Down, Left, Right)
                            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                            for (const [dr, dc] of directions) {
                                const nRow = r + dr;
                                const nCol = c + dc;

                                // Check if the neighbor is within grid bounds and has the same value
                                if (nRow >= 0 && nRow < GRID_SIZE && nCol >= 0 && nCol < GRID_SIZE &&
                                    gameGrid[nRow][nCol] === currentValue) {

                                    gameGrid[r][c] = currentValue * 2; // Double the value of the current block
                                    gameGrid[nRow][nCol] = 0; // Clear the merged block (it's now part of the doubled block)
                                    mergesOccurred = true; // A merge happened in this pass

                                    playMergeSound(); // Play merge sound

                                    // Add temporary merge animation class
                                    const mergedCellElement = gameGridDiv.querySelector(`[data-row="${r}"][data-col="${c}"] .grid-cell-content`);
                                    if (mergedCellElement) {
                                        mergedCellElement.classList.add('merge-pulse');
                                        setTimeout(() => {
                                            mergedCellElement.classList.remove('merge-pulse');
                                        }, 300); // Match animation duration
                                    }

                                    // Break from inner loop to restart the do-while loop.
                                    // This is crucial for cascading merges: if a block merges,
                                    // its new value might immediately merge with another neighbor.
                                    // By restarting the loop, we ensure the newly formed block is re-evaluated.
                                    break;
                                }
                            }
                            if (mergesOccurred) break; // If a merge occurred, break outer loop and restart do-while
                        }
                        if (mergesOccurred) break;
                    }
                } while (mergesOccurred); // Continue looping as long as merges are still occurring

                // After all possible merges are completed, make any floating blocks fall down
                dropAllBlocks();

                // Update score and highest value based on the new grid state
                calculateScore();
                getHighestValue();
            }

            /**
             * Makes all blocks in the grid fall to the lowest available space in their respective columns.
             */
            function dropAllBlocks() {
                for (let c = 0; c < GRID_SIZE; c++) { // Iterate through each column
                    let emptyRow = GRID_SIZE - 1; // Start from the bottom-most row
                    for (let r = GRID_SIZE - 1; r >= 0; r--) { // Iterate upwards from the bottom
                        if (gameGrid[r][c] !== 0) { // If there's a block in the current cell
                            if (r !== emptyRow) { // If it's not already at its lowest possible position
                                gameGrid[emptyRow][c] = gameGrid[r][c]; // Move the block down
                                gameGrid[r][c] = 0; // Clear the original position
                            }
                            emptyRow--; // Move up to find the next empty spot for the next block
                        }
                    }
                }
            }

            /**
             * Checks if the game is over. The game is over when the grid is completely full.
             */
            function checkGameOver() {
                let isGridFull = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (gameGrid[r][c] === 0) { // If any cell is empty, the grid is not full
                            isGridFull = false;
                            break;
                        }
                    }
                    if (!isGridFull) break;
                }

                if (isGridFull) {
                    showGameOverModal(); // Display the game over modal
                }
            }

            /**
             * Displays the game over modal with the final score and highest block.
             */
            function showGameOverModal() {
                saveHighScore(); // Save high score before showing modal
                finalScoreSpan.textContent = score; // Update final score in the modal
                modalHighestValueSpan.textContent = highestValue; // Update highest value in the modal
                gameOverModal.classList.add('show'); // Add 'show' class to make it visible
            }

            /**
             * Hides the game over modal.
             */
            function hideGameOverModal() {
                gameOverModal.classList.remove('show'); // Remove 'show' class to hide it
            }

            /**
             * Resets the game to its initial state, clearing the grid, drop zone, and scores.
             */
            function resetGame() {
                // Initialize grid with all empty cells (0)
                gameGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                dropZoneNumbers = []; // Clear drop zone
                undoCount = MAX_UNDO_COUNT; // Reset undo count
                score = 0; // Reset score
                highestValue = 0; // Reset highest value
                selectedDropZoneIndex = -1; // Deselect any drop zone item
                isDroppingMode = false; // Exit dropping mode
                firstSwapBlock = null; // Reset first swap block selection
                undoHistory = []; // Clear undo history
                hideGameOverModal(); // Hide the game over modal if it's visible
                loadHighScore(); // Load high score on reset
                updateUI(); // Refresh the UI to reflect the reset state
            }

            /**
             * Displays a temporary information message to the user (replaces alert()).
             * @param {string} message - The message to display.
             */
            function showInfoMessage(message) {
                // Remove any existing message to prevent multiple messages overlapping
                const existingMessage = document.getElementById('info-message');
                if (existingMessage) {
                    existingMessage.remove();
                }

                const infoDiv = document.createElement('div');
                infoDiv.id = 'info-message';
                infoDiv.textContent = message;
                document.body.appendChild(infoDiv);

                // Trigger fade-in animation
                setTimeout(() => {
                    infoDiv.style.opacity = 1;
                }, 10);

                // Trigger fade-out and removal after 3 seconds
                setTimeout(() => {
                    infoDiv.style.opacity = 0;
                    infoDiv.addEventListener('transitionend', () => infoDiv.remove());
                }, 3000);
            }

            /**
             * Handles resizing of the canvas to maintain responsiveness.
             */
            function resizeCanvas() {
                const containerWidth = topSectionDiv.clientWidth; // Use the width of the parent container
                dartboardCanvas.width = Math.min(containerWidth, 250); // Cap max width
                dartboardCanvas.height = Math.min(containerWidth, 250); // Keep it square
                drawDartboard(); // Redraw dartboard on resize
            }

            // Initial setup calls
            resetGame(); // Start a new game
            undoButton.addEventListener('click', handleUndoClick); // Attach undo button listener
            resetGameButton.addEventListener('click', resetGame); // Attach new Reset Game button listener
            restartButton.addEventListener('click', resetGame); // Attach restart button listener
            throwDartButton.addEventListener('click', handleThrowDartClick); // Attach throw dart button listener

            // Initial canvas resize and draw
            resizeCanvas();
            // Listen for window resize events to redraw the canvas
            window.addEventListener('resize', resizeCanvas);

            // Play background music and setup audio contexts on first user interaction
            const startAudio = () => {
                backgroundMusic.play().catch(error => {
                    console.error("Autoplay prevented:", error);
                    showInfoMessage("Click anywhere on the page to start the background music!");
                });
                setupAudio(); // Initialize Tone.js synths
                document.body.removeEventListener('click', startAudio); // Remove listener after first interaction
            };
            document.body.addEventListener('click', startAudio, { once: true });

            // If autoplay works immediately (e.g., in some dev environments), ensure audio context is set up
            if (backgroundMusic.paused === false || backgroundMusic.currentTime > 0) {
                 setupAudio();
            }
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DartMerge</title>
    <!-- Google Fonts: Inter for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for basic utilities and responsive classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Base styles for the body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background for a modern feel */
            color: #e2e8f0; /* Light text for contrast */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content is too tall */
        }

        /* Game container styling */
        #game-container {
            background-color: #2d3748; /* Slightly lighter dark background for the container */
            border-radius: 15px; /* Rounded corners for the container */
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3); /* Soft shadow for depth */
            width: 100%;
            max-width: 600px; /* Max width for better desktop experience */
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between sections */
            border: 2px solid #4a5568; /* Subtle border */
        }

        /* Title styling */
        h1 {
            text-align: center;
            font-size: 3.5rem; /* Increased heading size */
            font-weight: 700;
            color: #63b3ed; /* A vibrant blue for the title */
            text-shadow: 0 0 10px rgba(99, 179, 237, 0.5); /* Glowing text effect */
            margin-bottom: 20px;
        }

        /* Styling for all number blocks (top, drop zone, grid) */
        .number-block, .grid-cell-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px; /* Consistent size for blocks */
            height: 60px;
            border-radius: 10px; /* Rounded corners for blocks */
            font-weight: 700;
            font-size: 1.2rem;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; /* Smooth transitions for hover/active states */
            user-select: none; /* Prevent text selection */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); /* Soft shadow */
            border: 2px solid rgba(255, 255, 255, 0.1); /* Subtle white border */
            color: #e2e8f0; /* Text color for numbers */
        }

        /* Cursor for clickable elements */
        .clickable {
            cursor: pointer;
        }
        .clickable:hover:not(.disabled) {
            transform: translateY(-3px); /* Lift effect on hover */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .clickable:active:not(.disabled) {
            transform: translateY(0); /* Press effect on click */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .number-block.disabled {
            opacity: 0.5; /* Dim disabled blocks */
            cursor: not-allowed;
        }

        /* Specific block colors based on value */
        .block-2 { background-color: #63b3ed; } /* Light Blue */
        .block-4 { background-color: #48bb78; } /* Green */
        .block-8 { background-color: #ecc94b; } /* Yellow */
        .block-16 { background-color: #ed8936; } /* Orange */
        .block-32 { background-color: #f56565; } /* Red */
        .block-64 { background-color: #9f7aea; } /* Purple */
        .block-128 { background-color: #ed64a6; } /* Pink */
        .block-256 { background-color: #4fd1c5; } /* Teal */
        .block-512 { background-color: #a0522d; } /* Sienna Brown */
        .block-1024 { background-color: #2b6cb0; } /* Dark Blue */
        /* No 2048 block color needed as it's removed from options */
        .block-miss { background-color: #a0aec0; } /* Gray for 'Miss' */
        .block-bomb { background-color: #e53e3e; } /* Red for 'Bomb' */
        .block-block-swap { background-color: #805ad5; } /* Violet for 'Block Swap' */
        .block-hammer { background-color: #718096; } /* Dark Gray for 'Hammer' */
        .block-empty { background-color: #4a5568; } /* Background for empty grid cells */

        /* Top section for dartboard and button */
        #top-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background-color: #2d3748;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        #dartboard-canvas {
            background-color: #1a202c;
            border-radius: 50%; /* Make it round */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 350px; /* Increased size for dartboard */
            max-height: 350px;
            width: 100%; /* Responsive width */
            height: auto; /* Maintain aspect ratio */
            border: 5px solid #4a5568;
        }
        #dartboard-canvas.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Drop zone container */
        #drop-zone-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background-color: #2d3748;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #drop-zone {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 70px; /* Ensure space even when empty */
            align-items: center;
            width: 100%;
        }
        #drop-zone .number-block {
            width: 60px; /* Standard size for drop zone blocks */
            height: 60px;
            font-size: 1.2rem;
            border: 2px dashed #90cdf4; /* Dashed border for visual distinction */
        }
        #drop-zone .number-block.selected-for-drop {
            border: 2px solid #fc8181; /* Red border when selected for dropping */
            box-shadow: 0 0 15px rgba(252, 129, 129, 0.7); /* Red glow when selected */
        }

        /* Action buttons (Undo, Reset Game) */
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
        }
        .action-buttons button {
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
            color: #e2e8f0;
            background-image: linear-gradient(to right, #4299e1, #63b3ed); /* Blue gradient */
        }
        .action-buttons button#miss-button {
            background-image: linear-gradient(to right, #a0aec0, #cbd5e0); /* Gray gradient for Miss button */
        }
        .action-buttons button#miss-button:hover:not(:disabled) {
            background-image: linear-gradient(to right, #718096, #a0aec0);
        }
        .action-buttons button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-image: linear-gradient(to right, #3182ce, #4299e1);
        }
        .action-buttons button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .action-buttons button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-image: linear-gradient(to right, #a0aec0, #cbd5e0);
        }

        /* Game grid styling */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 columns, equal width */
            grid-template-rows: repeat(5, 1fr); /* 5 rows, equal height */
            gap: 5px; /* Space between grid cells */
            width: 100%;
            aspect-ratio: 1 / 1; /* Make the grid perfectly square */
            background-color: #1a202c;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); /* Inner shadow for depth */
            border: 2px solid #4a5568;
        }
        .grid-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4a5568; /* Background for empty cells */
            border-radius: 8px;
            position: relative;
            overflow: hidden; /* Important for glowing effect to stay within bounds */
            transition: background-color 0.2s ease-in-out;
        }
        /* Only apply active/hover styles if a block is selected */
        .grid-cell.column-active {
            box-shadow: 0 0 0 3px #90cdf4, inset 0 0 0 3px #90cdf4; /* Highlight active column for dropping */
            cursor: pointer;
        }
        .grid-cell.column-active:hover {
            background-color: #5a667a; /* Slightly lighter on hover when active */
        }
        /* New style for selected swap blocks */
        .grid-cell.selected-for-swap {
            box-shadow: 0 0 0 4px #805ad5, inset 0 0 0 4px #805ad5; /* Violet glow for selected swap block */
            background-color: #6b46c1; /* Slightly darker violet */
        }
        .grid-cell.selected-for-swap:hover {
            background-color: #744edc; /* Lighter violet on hover */
        }
        /* New style for selected hammer target */
        .grid-cell.selected-for-hammer {
            box-shadow: 0 0 0 4px #e53e3e, inset 0 0 0 4px #e53e3e; /* Red glow for hammer target */
            background-color: #c53030; /* Slightly darker red */
        }
        .grid-cell.selected-for-hammer:hover {
            background-color: #d64545; /* Lighter red on hover */
        }


        /* Keyframe animation for the glowing effect */
        @keyframes glow {
            0% { box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #63b3ed, 0 0 20px #63b3ed, 0 0 25px #63b3ed, 0 0 30px #63b3ed, 0 0 35px #63b3ed; }
            100% { box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #63b3ed, 0 0 40px #63b3ed, 0 0 50px #63b3ed, 0 0 60px #63b3ed, 0 0 70px #63b3ed; }
        }
        /* Apply glowing animation to the highest value block */
        .grid-cell-content.glowing {
            animation: glow 1.5s infinite alternate; /* Continuous, alternating glow */
        }

        /* New style for merge animation */
        @keyframes mergePulse {
            0% { transform: scale(1); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(99, 179, 237, 0.8), 0 0 40px rgba(99, 179, 237, 0.6); }
            100% { transform: scale(1); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); }
        }
        .grid-cell-content.merge-pulse {
            animation: mergePulse 0.3s ease-out;
        }

        /* Game info section (Score, Highest Value) */
        #game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2rem;
            font-weight: 700;
            color: #90cdf4; /* Blue text for info */
        }

        /* Game Over Modal */
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            visibility: hidden; /* Hidden by default */
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease-in-out; /* Smooth fade in/out */
        }
        #game-over-modal.show {
            visibility: visible;
            opacity: 1;
        }
        #game-over-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
            max-width: 90%; /* Responsive width */
        }
        #game-over-content h2 {
            font-size: 2.5rem;
            color: #fc8181; /* Red for "Game Over" */
            margin-bottom: 20px;
        }
        #game-over-content p {
            font-size: 1.5rem;
            margin-bottom: 25px;
        }
        #game-over-content button {
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-image: linear-gradient(to right, #48bb78, #68d391); /* Green gradient for restart */
            color: #e2e8f0;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        #game-over-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-image: linear-gradient(to right, #38a169, #48bb78); /* Darker green on hover */
        }

        /* Info Message Box (replaces alert()) */
        #info-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4299e1; /* Blue background */
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1001; /* Above modal */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .number-block, .grid-cell-content {
                width: 50px;
                height: 50px;
                font-size: 1rem;
            }
            #dartboard-canvas {
                max-width: 250px; /* Slightly smaller on mobile */
                max-height: 250px;
            }
            #drop-zone .number-block {
                width: 55px;
                height: 55px;
                font-size: 1.1rem;
            }
            .action-buttons button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            #game-info {
                font-size: 1rem;
            }
            #game-over-content h2 {
                font-size: 2rem;
            }
            #game-over-content p {
                font-size: 1.2rem;
            }
            #game-over-content button {
                padding: 12px 25px;
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Audio tag for background music. Removed `autoplay` to comply with browser policies. -->
    <audio id="background-music" src="Dartsmerge Theme Song.mp3" loop></audio>

    <!-- Info Message Box (replaces alert()) -->
    <div id="info-message"></div>

    <div id="game-container">
        <h1>DartMerge</h1>

        <!-- Section for the dartboard -->
        <div id="top-section">
            <canvas id="dartboard-canvas" class="clickable"></canvas>
        </div>

        <!-- Section for the drop zone and action buttons -->
        <div id="drop-zone-container">
            <div id="drop-zone">
                <!-- Numbers dropped from the top will appear here -->
            </div>
            <div class="action-buttons">
                <button id="undo-button">Undo</button>
                <button id="miss-button">Miss</button>
                <button id="reset-game-button">Reset Game</button>
            </div>
        </div>

        <!-- The 5x5 game grid -->
        <div id="game-grid">
            <!-- Grid cells and their contents will be dynamically rendered here by JavaScript -->
        </div>

        <!-- Game information: Score and Highest Value -->
        <div id="game-info">
            <span>Score: <span id="score">0</span></span>
            <span>Highest: <span id="highest-value">0</span></span>
            <span>High Score: <span id="high-score">0</span></span>
        </div>
    </div>

    <!-- Game Over Modal (hidden by default) -->
    <div id="game-over-modal">
        <div id="game-over-content">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Highest Block: <span id="modal-highest-value">0</span></p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // Dartboard specific constants
        const DARTBOARD_SEGMENTS_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

        // User-defined mapping for single segments
        const DARTBOARD_SINGLE_SEGMENT_MAPPING = {
            20: 2, 1: 2,
            18: 4, 4: 4,
            13: 8, 6: 8,
            10: 16, 15: 16,
            2: 32, 17: 32,
            3: 64, 19: 64,
            7: 128, 16: 128,
            8: 256, 11: 256,
            14: 512, 9: 512,
            12: 1024, 5: 1024
        };

        const MAX_DROP_ZONE_SIZE = 3; // Maximum numbers allowed in the drop zone
        const GRID_SIZE = 5;          // The grid dimensions (5x5)
        const HIGH_SCORE_KEY = 'dartMergeHighScore'; // Key for localStorage

        // Mapping values to their corresponding CSS color classes
        const blockColors = {
            2: 'block-2',
            4: 'block-4',
            8: 'block-8',
            16: 'block-16',
            32: 'block-32',
            64: 'block-64',
            128: 'block-128',
            256: 'block-256',
            512: 'block-512',
            1024: 'block-1024',
            'Miss': 'block-miss',
            'Bomb': 'block-bomb',
            'Block Swap': 'block-block-swap',
            'Hammer': 'block-hammer',
            0: 'block-empty' // Class for empty grid cells
        };

        // All game logic and variables are now encapsulated within the window.onload function
        window.onload = function () {
            // Game state variables, initialized to their default values
            let gameGrid = []; // Represents the 5x5 game board, 0 indicates an empty cell
            let dropZoneNumbers = []; // Array to hold numbers currently in the drop zone
            let score = 0; // Current game score
            let highestValue = 0; // Highest number currently in the grid
            let highScore = 0; // Persistent high score
            let selectedDropZoneIndex = -1; // Index of the number selected in drop zone (-1 means none)
            let isDroppingMode = false; // Flag to indicate if a number is selected for dropping into the grid
            let firstSwapBlock = null; // Stores [row, col] of the first block selected for Block Swap
            let undoHistory = []; // Stores previous game states for the undo functionality

            // Get references to key DOM elements - assigned here to ensure they are available
            const dartboardCanvas = document.getElementById('dartboard-canvas');
            const ctx = dartboardCanvas.getContext('2d');
            const dropZoneDiv = document.getElementById('drop-zone');
            const undoButton = document.getElementById('undo-button');
            const missButton = document.getElementById('miss-button');
            const resetGameButton = document.getElementById('reset-game-button');
            const gameGridDiv = document.getElementById('game-grid');
            const scoreSpan = document.getElementById('score');
            const highestValueSpan = document.getElementById('highest-value');
            const highScoreSpan = document.getElementById('high-score');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreSpan = document.getElementById('final-score');
            const modalHighestValueSpan = document.getElementById('modal-highest-value');
            const restartButton = document.getElementById('restart-button');
            const backgroundMusic = document.getElementById('background-music');
            const topSectionDiv = document.getElementById('top-section');

            // Tone.js setup for sound effects
            let dropSynth, mergeSynth, missSynth, bombSynth, hammerSynth, swapSynth;

            /**
             * Initializes Tone.js synths for various sound effects.
             * This function is now called immediately at game start to prevent undefined errors.
             */
            function setupAudio() {
                // We don't need to check Tone.context.state here since it will be started
                // by the user interaction event listener later.
                try {
                    dropSynth = new Tone.MembraneSynth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }
                    }).toDestination();

                    mergeSynth = new Tone.Synth({
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.1 }
                    }).toDestination();

                    missSynth = new Tone.NoiseSynth({
                        noise: { type: "pink" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }
                    }).toDestination();

                    bombSynth = new Tone.MetalSynth({
                        envelope: { decay: 0.3, sustain: 0.1 },
                        resonance: 0.9
                    }).toDestination();

                    hammerSynth = new Tone.PluckSynth({
                        attackNoise: 1,
                        dampening: 4000,
                        resonance: 0.9
                    }).toDestination();

                    swapSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sawtooth" },
                        envelope: { attack: 0.02, decay: 0.1, sustain: 0.0, release: 0.2 }
                    }).toDestination();
                } catch (e) {
                    console.error("Failed to initialize Tone.js synths:", e);
                }
            }
            
            function playDropSound() { try { dropSynth.triggerAttackRelease("C3", "8n"); } catch(e) { console.error("Error playing drop sound:", e); } }
            function playMergeSound() { try { mergeSynth.triggerAttackRelease("E5", "16n"); } catch(e) { console.error("Error playing merge sound:", e); } }
            function playMissSound() { try { missSynth.triggerAttackRelease("8n"); } catch(e) { console.error("Error playing miss sound:", e); } }
            function playBombSound() { try { bombSynth.triggerAttackRelease("C2", "1n"); } catch(e) { console.error("Error playing bomb sound:", e); } }
            function playHammerSound() { try { hammerSynth.triggerAttackRelease("A2", "8n"); } catch(e) { console.error("Error playing hammer sound:", e); } }
            function playSwapSound() { try { swapSynth.triggerAttackRelease(["C5", "G5"], "8n"); } catch(e) { console.error("Error playing swap sound:", e); } }


            /**
             * Returns the CSS class name for a given number value or special block.
             * @param {number|string} value - The block value (e.g., 2, 'Miss', 'Bomb', 'Block Swap', 'Hammer').
             * @returns {string} The corresponding CSS class name.
             */
            function getBlockColorClass(value) {
                return blockColors[value] || 'block-empty';
            }

            /**
             * Loads the high score from localStorage.
             */
            function loadHighScore() {
                const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
                highScore = storedHighScore ? parseInt(storedHighScore, 10) : 0;
            }

            /**
             * Saves the current high score to localStorage if it's higher than the stored one.
             */
            function saveHighScore() {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem(HIGH_SCORE_KEY, highScore.toString());
                }
            }

            /**
             * Draws the dartboard on the canvas.
             */
            function drawDartboard() {
                const size = dartboardCanvas.width;
                const center = size / 2;
                const radius = size / 2 - 5; // Leave some padding for border

                ctx.clearRect(0, 0, size, size); // Clear canvas

                // Define ring radii (relative to total radius)
                const bullseyeRadius = radius * 0.05;
                const outerBullRadius = radius * 0.12;
                const tripleInnerRadius = radius * 0.5;
                const tripleOuterRadius = radius * 0.6;
                const doubleInnerRadius = radius * 0.9;
                const doubleOuterRadius = radius * 1.0;
                const numberRingRadius = radius * 0.75; // New radius for numbers, between triple and double rings

                const segmentAngle = (Math.PI * 2) / 20; // Angle for each of 20 segments

                // Draw segments and rings
                for (let i = 0; i < 20; i++) {
                    // Adjust start and end angles so that 20 is at the top, and segments are clockwise
                    const currentSegmentStartAngle = (i * segmentAngle) - (Math.PI / 2) - (segmentAngle / 2);
                    const currentSegmentEndAngle = ((i + 1) * segmentAngle) - (Math.PI / 2) - (segmentAngle / 2);

                    // Outer Single (between double and triple)
                    ctx.beginPath();
                    ctx.arc(center, center, doubleInnerRadius, currentSegmentStartAngle, currentSegmentEndAngle);
                    ctx.arc(center, center, tripleOuterRadius, currentSegmentEndAngle, currentSegmentStartAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = (i % 2 === 0) ? '#333' : '#eee'; // Alternating dark/light gray
                    ctx.fill();

                    // Inner Single
                    ctx.beginPath();
                    ctx.arc(center, center, tripleInnerRadius, currentSegmentStartAngle, currentSegmentEndAngle);
                    ctx.arc(center, center, outerBullRadius, currentSegmentEndAngle, currentSegmentStartAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = (i % 2 === 0) ? '#eee' : '#333'; // Alternating light/dark gray
                    ctx.fill();
                }

                // Draw Triple Ring
                ctx.beginPath();
                ctx.arc(center, center, tripleOuterRadius, 0, Math.PI * 2);
                ctx.arc(center, center, tripleInnerRadius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fillStyle = '#f56565'; // Red for Bomb
                ctx.fill();

                // Draw Double Ring
                ctx.beginPath();
                ctx.arc(center, center, doubleOuterRadius, 0, Math.PI * 2);
                ctx.arc(center, center, doubleInnerRadius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fillStyle = '#48bb78'; // Green for Hammer
                ctx.fill();

                // Draw Outer Bull
                ctx.beginPath();
                ctx.arc(center, center, outerBullRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#48bb78'; // Green
                ctx.fill();

                // Draw Bullseye
                ctx.beginPath();
                ctx.arc(center, center, bullseyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#f56565'; // Red
                ctx.fill();

                // Draw lines for segments
                ctx.strokeStyle = '#2d3748'; // Darker line color
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    const angle = (i * segmentAngle) - (Math.PI / 2) - (segmentAngle / 2); // Line from center to edge
                    ctx.beginPath();
                    ctx.moveTo(center, center);
                    ctx.lineTo(center + radius * Math.cos(angle), center + radius * Math.sin(angle));
                    ctx.stroke();
                }

                // Draw outer border
                ctx.beginPath();
                ctx.arc(center, center, radius, 0, Math.PI * 2);
                ctx.strokeStyle = '#e2e8f0'; // Light border
                ctx.lineWidth = 3;
                ctx.stroke();

                // --- Draw Text on the Dartboard ---
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add a white outline for all text
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;

                // Draw numbers for the single segments on the outside ring
                ctx.font = 'bold 16px Inter';
                for (let i = 0; i < 20; i++) {
                    const originalSegment = DARTBOARD_SEGMENTS_ORDER[i];
                    const generatedValue = DARTBOARD_SINGLE_SEGMENT_MAPPING[originalSegment];
                    const angle = (i * segmentAngle) - (Math.PI / 2); // Angle to center of the segment
                    
                    const x = center + numberRingRadius * Math.cos(angle);
                    const y = center + numberRingRadius * Math.sin(angle);
                    
                    ctx.fillStyle = '#63b3ed'; // Vibrant blue text color
                    ctx.fillText(generatedValue, x, y);
                    ctx.strokeText(generatedValue, x, y); // Draw the white outline
                }

                // Draw "BOMB" text in the triple ring
                ctx.font = 'bold 20px Inter';
                ctx.fillStyle = '#63b3ed';
                ctx.fillText('BOMB', center, center + radius * 0.55);
                ctx.strokeText('BOMB', center, center + radius * 0.55);

                // Draw "HAMMER" text in the double ring
                ctx.font = 'bold 20px Inter';
                ctx.fillStyle = '#63b3ed';
                ctx.fillText('HAMMER', center, center + radius * 0.95);
                ctx.strokeText('HAMMER', center, center + radius * 0.95);
                
                // Draw "BLOCK SWAP" in the bullseye
                ctx.font = 'bold 10px Inter';
                ctx.fillStyle = '#63b3ed';
                ctx.fillText('BLOCK', center, center - 5);
                ctx.strokeText('BLOCK', center, center - 5);
                ctx.fillText('SWAP', center, center + 5);
                ctx.strokeText('SWAP', center, center + 5);

                ctx.restore();
            }


            /**
             * Generates a new number or special block based on the dartboard hit location.
             * @param {number} x - The x-coordinate of the click.
             * @param {number} y - The y-coordinate of the click.
             * @returns {number|string|null} The generated value or null if a miss.
             */
            function generateBlockFromDartboard(x, y) {
                const size = dartboardCanvas.width;
                const center = size / 2;
                const radius = size / 2 - 5;
                
                // Calculate distance from center
                const dx = x - center;
                const dy = y - center;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check for a miss first (outside the board)
                if (distance > radius) {
                    return 'Miss';
                }

                // Bullseye/Outer Bull (Block Swap)
                if (distance <= radius * 0.12) {
                    return 'Block Swap';
                }

                // Triple Ring (Bomb)
                if (distance >= radius * 0.5 && distance <= radius * 0.6) {
                    return 'Bomb';
                }
                
                // Double Ring (Hammer)
                if (distance >= radius * 0.9 && distance <= radius * 1.0) {
                    return 'Hammer';
                }

                // Single segments
                // Calculate angle from center
                let angle = Math.atan2(dy, dx);
                if (angle < 0) {
                    angle += 2 * Math.PI;
                }
                
                // Adjust for the dartboard's starting position (segment 20 at the top)
                const segmentAngle = (Math.PI * 2) / 20;
                let adjustedAngle = angle + (Math.PI / 2) + (segmentAngle / 2);
                if (adjustedAngle > 2 * Math.PI) {
                    adjustedAngle -= 2 * Math.PI;
                }
                const segmentIndex = Math.floor(adjustedAngle / segmentAngle);
                const originalSegment = DARTBOARD_SEGMENTS_ORDER[segmentIndex];
                
                // Only return the number if the dart hits in the single segment rings
                if (distance >= radius * 0.12 && distance < radius * 0.5 || distance > radius * 0.6 && distance < radius * 0.9) {
                     return DARTBOARD_SINGLE_SEGMENT_MAPPING[originalSegment];
                }
                
                // Fallback for areas not explicitly defined (like the inner rings without numbers)
                return 'Miss';
            }


            /**
             * Initializes the game grid with empty cells (value 0).
             */
            function initializeGrid() {
                gameGrid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
            }

            /**
             * Renders the current game grid to the DOM.
             */
            function renderGrid() {
                gameGridDiv.innerHTML = ''; // Clear the grid
                let highestBlockValue = 0;

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        const value = gameGrid[r][c];
                        if (value !== 0) {
                            const block = document.createElement('div');
                            block.className = `grid-cell-content ${getBlockColorClass(value)}`;
                            block.textContent = value;
                            cell.appendChild(block);

                            if (typeof value === 'number' && value > highestBlockValue) {
                                highestBlockValue = value;
                            }
                        }
                        gameGridDiv.appendChild(cell);
                    }
                }
                highestValue = highestBlockValue;
                updateGameInfo();
                
                // Add glowing class to the highest value block
                const highestBlocks = document.querySelectorAll(`.block-${highestValue}`);
                highestBlocks.forEach(block => block.classList.add('glowing'));
            }

            /**
             * Renders the numbers in the drop zone.
             */
            function renderDropZone() {
                dropZoneDiv.innerHTML = '';
                dropZoneNumbers.forEach((value, index) => {
                    const block = document.createElement('div');
                    block.className = `number-block clickable ${getBlockColorClass(value)}`;
                    block.textContent = value;
                    block.dataset.index = index;
                    block.addEventListener('click', () => handleDropZoneClick(index));
                    dropZoneDiv.appendChild(block);
                });
            }
            
            /**
             * Handles a click on a number in the drop zone.
             * @param {number} index - The index of the clicked number.
             */
            function handleDropZoneClick(index) {
                if (selectedDropZoneIndex === index) {
                    // Deselect if clicking the same block again
                    deselectDropZoneBlock();
                } else {
                    // Select the new block
                    deselectDropZoneBlock();
                    selectedDropZoneIndex = index;
                    isDroppingMode = true;
                    
                    const blockToDrop = dropZoneDiv.children[index];
                    blockToDrop.classList.add('selected-for-drop');
                    
                    highlightDroppableColumns();
                }
            }

            /**
             * Deselects the currently selected block in the drop zone.
             */
            function deselectDropZoneBlock() {
                if (selectedDropZoneIndex !== -1) {
                    dropZoneDiv.children[selectedDropZoneIndex].classList.remove('selected-for-drop');
                    selectedDropZoneIndex = -1;
                    isDroppingMode = false;
                    unhighlightDroppableColumns();
                }
            }

            /**
             * Highlights the columns where a block can be dropped.
             */
            function highlightDroppableColumns() {
                const cells = document.querySelectorAll('#game-grid .grid-cell');
                cells.forEach(cell => {
                    const col = parseInt(cell.dataset.col, 10);
                    // Check if the top cell of the column is empty
                    if (gameGrid[0][col] === 0) {
                        cell.classList.add('column-active');
                    }
                });
            }

            /**
             * Removes the highlight from all columns.
             */
            function unhighlightDroppableColumns() {
                const cells = document.querySelectorAll('#game-grid .grid-cell');
                cells.forEach(cell => {
                    cell.classList.remove('column-active');
                });
            }

            /**
             * Updates the score, highest value, and high score displays.
             */
            function updateGameInfo() {
                scoreSpan.textContent = score;
                highestValueSpan.textContent = highestValue;
                highScoreSpan.textContent = highScore;
            }

            /**
             * Saves the current game state to the undo history.
             */
            function saveState() {
                undoHistory.push({
                    grid: JSON.parse(JSON.stringify(gameGrid)),
                    dropZone: [...dropZoneNumbers],
                    score: score,
                    highest: highestValue
                });
                // Keep history size manageable, e.g., last 10 states
                if (undoHistory.length > 10) {
                    undoHistory.shift();
                }
            }

            /**
             * Loads the last saved state from the undo history.
             */
            function undoLastMove() {
                if (undoHistory.length > 0) {
                    const lastState = undoHistory.pop();
                    gameGrid = lastState.grid;
                    dropZoneNumbers = lastState.dropZone;
                    score = lastState.score;
                    highestValue = lastState.highest;
                    renderGrid();
                    renderDropZone();
                    updateGameInfo();
                    showMessage('Undo successful!', 'info');
                } else {
                    showMessage('No moves to undo!', 'error');
                }
            }
            
            /**
             * Displays an info message box (instead of using alert).
             * @param {string} message - The message to display.
             * @param {string} type - 'info', 'error', 'success'.
             */
            function showMessage(message, type = 'info') {
                const infoMessageDiv = document.getElementById('info-message');
                if (!infoMessageDiv) return;

                infoMessageDiv.textContent = message;
                infoMessageDiv.style.opacity = '1';
                
                // Set color based on type
                if (type === 'error') {
                    infoMessageDiv.style.backgroundColor = '#e53e3e';
                } else if (type === 'success') {
                    infoMessageDiv.style.backgroundColor = '#48bb78';
                } else {
                    infoMessageDiv.style.backgroundColor = '#4299e1';
                }

                // Hide the message after 3 seconds
                setTimeout(() => {
                    infoMessageDiv.style.opacity = '0';
                }, 3000);
            }


            /**
             * Checks for adjacent identical numbers and merges them.
             * @param {number} r - Row index.
             * @param {number} c - Column index.
             * @returns {boolean} - True if a merge occurred, false otherwise.
             */
            function checkAndMerge(r, c) {
                const value = gameGrid[r][c];
                if (value === 0 || typeof value !== 'number') return false;

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
                let merged = false;

                for (const [dr, dc] of directions) {
                    const newR = r + dr;
                    const newC = c + dc;
                    if (newR >= 0 && newR < GRID_SIZE && newC >= 0 && newC < GRID_SIZE) {
                        const neighborValue = gameGrid[newR][newC];
                        if (neighborValue === value) {
                            // Merge
                            const newValue = value * 2;
                            gameGrid[r][c] = newValue;
                            gameGrid[newR][newC] = 0; // Clear the old cell
                            score += newValue;
                            highestValue = Math.max(highestValue, newValue);
                            merged = true;
                            
                            // Add a visual pulse animation
                            const mergedBlockEl = document.querySelector(`.grid-cell[data-row='${r}'][data-col='${c}'] .grid-cell-content`);
                            if (mergedBlockEl) {
                                mergedBlockEl.classList.add('merge-pulse');
                                mergedBlockEl.addEventListener('animationend', () => {
                                    mergedBlockEl.classList.remove('merge-pulse');
                                }, { once: true });
                            }
                            playMergeSound();
                            
                            // Recursively check for further merges from the new block
                            checkAndMerge(r, c);
                        }
                    }
                }
                return merged;
            }

            /**
             * Checks for adjacent number matches and merges them.
             * This function is triggered after a block is placed.
             */
            function checkAllMerges() {
                let merged = false;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (checkAndMerge(r, c)) {
                            merged = true;
                        }
                    }
                }
                if (merged) {
                    // Re-render the grid to show new state after merges
                    renderGrid();
                }
            }

            /**
             * Handles special blocks.
             * @param {string} blockType - The type of special block ('Bomb', 'Block Swap', 'Hammer').
             * @param {number} row - The row where the block was dropped.
             * @param {number} col - The column where the block was dropped.
             */
            function handleSpecialBlock(blockType, row, col) {
                if (blockType === 'Bomb') {
                    // Clear the block itself and all surrounding blocks
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1], [0, 0]];
                    let blocksRemoved = 0;
                    directions.forEach(([dr, dc]) => {
                        const targetR = row + dr;
                        const targetC = col + dc;
                        if (targetR >= 0 && targetR < GRID_SIZE && targetC >= 0 && targetC < GRID_SIZE) {
                            if (gameGrid[targetR][targetC] !== 0) {
                                gameGrid[targetR][targetC] = 0;
                                blocksRemoved++;
                            }
                        }
                    });
                    score += blocksRemoved * 10; // Award points for cleared blocks
                    playBombSound();
                    renderGrid();
                    showMessage('Bomb deployed!', 'success');
                } else if (blockType === 'Block Swap') {
                    // Set the mode for swapping
                    gameGridDiv.classList.add('swapping-mode');
                    showMessage('Select two blocks to swap.', 'info');
                    // We handle the click event on the grid cells to perform the swap
                } else if (blockType === 'Hammer') {
                    // Set the mode for hammering
                    gameGridDiv.classList.add('hammer-mode');
                    showMessage('Select a single block to destroy.', 'info');
                    // We handle the click event on the grid cells to perform the hammer action
                }
            }

            /**
             * Checks if the game is over (grid is full).
             * @returns {boolean} - True if the grid is full, false otherwise.
             */
            function isGameOver() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (gameGrid[r][c] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            /**
             * Displays the game over modal.
             */
            function showGameOverModal() {
                saveHighScore();
                finalScoreSpan.textContent = score;
                modalHighestValueSpan.textContent = highestValue;
                gameOverModal.classList.add('show');
                // Disable dartboard and other buttons
                dartboardCanvas.classList.add('disabled');
                undoButton.disabled = true;
                missButton.disabled = true;
                resetGameButton.disabled = true;
            }


            // --- Event Listeners ---

            /**
             * Handles a click on the dartboard canvas.
             * @param {Event} event - The click event object.
             */
            function handleDartboardClick(event) {
                if (dropZoneNumbers.length >= MAX_DROP_ZONE_SIZE || isDroppingMode || gameGridDiv.classList.contains('swapping-mode') || gameGridDiv.classList.contains('hammer-mode')) {
                    showMessage('Drop your current blocks first!', 'error');
                    return;
                }

                // Get coordinates relative to the canvas
                const rect = dartboardCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const generatedBlock = generateBlockFromDartboard(x, y);

                if (generatedBlock === 'Miss') {
                    showMessage('Missed!', 'error');
                    playMissSound();
                } else {
                    // Add the generated block to the drop zone
                    dropZoneNumbers.push(generatedBlock);
                    renderDropZone();
                    showMessage(`Generated: ${generatedBlock}`, 'success');
                    playDropSound();
                }
            }
            
            /**
             * Handles a click on the game grid.
             * @param {Event} event - The click event object.
             */
            function handleGridClick(event) {
                const cell = event.target.closest('.grid-cell');
                if (!cell) return;

                const row = parseInt(cell.dataset.row, 10);
                const col = parseInt(cell.dataset.col, 10);
                const valueInCell = gameGrid[row][col];
                
                // Handle Block Swap Mode
                if (gameGridDiv.classList.contains('swapping-mode')) {
                    if (firstSwapBlock === null) {
                        // First block of the swap
                        if (valueInCell !== 0) {
                            firstSwapBlock = { row, col };
                            cell.classList.add('selected-for-swap');
                        } else {
                            showMessage('Select a block to swap.', 'error');
                        }
                    } else {
                        // Second block of the swap
                        if (firstSwapBlock.row === row && firstSwapBlock.col === col) {
                            // Deselect if the same block is clicked again
                            cell.classList.remove('selected-for-swap');
                            firstSwapBlock = null;
                        } else {
                            // Perform the swap
                            const tempValue = gameGrid[firstSwapBlock.row][firstSwapBlock.col];
                            gameGrid[firstSwapBlock.row][firstSwapBlock.col] = gameGrid[row][col];
                            gameGrid[row][col] = tempValue;
                            
                            // Reset state
                            firstSwapBlock = null;
                            gameGridDiv.classList.remove('swapping-mode');
                            renderGrid();
                            playSwapSound();
                            showMessage('Blocks swapped!', 'success');
                        }
                    }
                    return;
                }

                // Handle Hammer Mode
                if (gameGridDiv.classList.contains('hammer-mode')) {
                    if (valueInCell !== 0) {
                        gameGrid[row][col] = 0; // Destroy the block
                        renderGrid();
                        playHammerSound();
                        showMessage('Block hammered!', 'success');
                        
                        // Reset state
                        gameGridDiv.classList.remove('hammer-mode');
                    } else {
                        showMessage('Select a block to hammer.', 'error');
                    }
                    return;
                }

                // Handle regular dropping mode
                if (isDroppingMode) {
                    const blockValue = dropZoneNumbers[selectedDropZoneIndex];

                    // Find the lowest empty cell in the selected column
                    let dropRow = -1;
                    for (let r = GRID_SIZE - 1; r >= 0; r--) {
                        if (gameGrid[r][col] === 0) {
                            dropRow = r;
                            break;
                        }
                    }
                    
                    if (dropRow !== -1) {
                        saveState();
                        gameGrid[dropRow][col] = blockValue;
                        
                        // Handle special blocks immediately after dropping
                        if (typeof blockValue !== 'number') {
                            handleSpecialBlock(blockValue, dropRow, col);
                        } else {
                            // Check and merge after placing a number block
                            checkAndMerge(dropRow, col);
                            // We need a full re-render here to capture all cascading merges
                            renderGrid();
                        }
                        
                        // Remove the block from the drop zone
                        dropZoneNumbers.splice(selectedDropZoneIndex, 1);
                        
                        // Reset drop mode
                        deselectDropZoneBlock();
                        
                        // Re-render and check for game over
                        renderDropZone();
                        renderGrid();
                        if (isGameOver()) {
                            showGameOverModal();
                        }
                    } else {
                        showMessage('Column is full!', 'error');
                    }
                } else {
                    // Do nothing if no block is selected in drop zone
                    showMessage('Select a block from the drop zone first.', 'info');
                }
            }
            
            /**
             * Handles a click on the undo button.
             */
            function handleUndoClick() {
                undoLastMove();
            }

            /**
             * Handles a click on the "Miss" button.
             */
            function handleMissButtonClick() {
                if (dropZoneNumbers.length >= MAX_DROP_ZONE_SIZE || isDroppingMode || gameGridDiv.classList.contains('swapping-mode') || gameGridDiv.classList.contains('hammer-mode')) {
                    showMessage('Drop your current blocks first!', 'error');
                    return;
                }

                dropZoneNumbers.push('Miss');
                renderDropZone();
                showMessage('Generated: Miss', 'success');
                playMissSound();
            }

            /**
             * Handles a click on the reset game button.
             */
            function handleResetGameClick() {
                if (confirm('Are you sure you want to reset the game? This cannot be undone.')) {
                    startGame();
                    showMessage('Game has been reset.', 'info');
                }
            }

            /**
             * Handles a click on the restart button in the game over modal.
             */
            function handleRestartClick() {
                gameOverModal.classList.remove('show');
                startGame();
            }

            /**
             * Handles window resize to keep the canvas square and centered.
             */
            function handleResize() {
                const containerWidth = topSectionDiv.offsetWidth;
                const newSize = Math.min(containerWidth, 350); // Cap at 350px
                dartboardCanvas.width = newSize;
                dartboardCanvas.height = newSize;
                drawDartboard();
            }


            // --- Game Initialization ---
            function startGame() {
                // Initialize state variables
                initializeGrid();
                dropZoneNumbers = [];
                score = 0;
                highestValue = 0;
                selectedDropZoneIndex = -1;
                isDroppingMode = false;
                firstSwapBlock = null;
                undoHistory = [];
                
                // Enable dartboard and buttons
                dartboardCanvas.classList.remove('disabled');
                undoButton.disabled = false;
                missButton.disabled = false;
                resetGameButton.disabled = false;
                
                // Render the initial state
                renderGrid();
                renderDropZone();
                updateGameInfo();
            }

            // Bind event listeners
            dartboardCanvas.addEventListener('click', handleDartboardClick);
            gameGridDiv.addEventListener('click', handleGridClick);
            undoButton.addEventListener('click', handleUndoClick);
            missButton.addEventListener('click', handleMissButtonClick);
            resetGameButton.addEventListener('click', handleResetGameClick);
            restartButton.addEventListener('click', handleRestartClick);
            
            window.addEventListener('resize', handleResize);

            // Initial setup. This is now called right away.
            setupAudio();
            handleResize(); // Set initial canvas size
            loadHighScore();
            startGame();
            
            // Start audio on first user interaction
            document.body.addEventListener('click', () => {
                // Start Tone.js audio context on first user click
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                backgroundMusic.play().catch(e => console.error("Audio playback failed:", e));
            }, { once: true });
        };
    </script>
</body>
</html>
